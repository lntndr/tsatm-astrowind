---
import Button from '~/components/ui/Button.astro';
import { Image } from 'astro:assets';
import type { Hero as Props } from '~/types';

// Import the slideshow config
import { slideshowImages as configSlideshowImages } from '~/assets/images/slideshow/config';

export interface SlideHeroProps extends Props {
  slideshow?: {
    images?: Array<{ filename: string; alt?: string; caption?: string }>;
    folder?: string;
    duration?: number;
  };
}

const {
  title = await Astro.slots.render('title'),
  subtitle = await Astro.slots.render('subtitle'),
  tagline,
  content = await Astro.slots.render('content'),
  actions = await Astro.slots.render('actions'),
  id,
  anchorId,
  slideshow = { folder: 'slideshow', duration: 3000 },
} = Astro.props as SlideHeroProps;

const slideshowImagesConfig = slideshow.images || configSlideshowImages;
const slideshowFolder = slideshow.folder || 'slideshow';
const imageDuration = slideshow.duration || 3000;

const imageModules = import.meta.glob('/src/assets/images/**/*.{jpg,jpeg,png,webp,JPG,JPEG,PNG,WEBP}', { eager: false });

let processedImages = [];

if (slideshowImagesConfig) {
  for (const config of slideshowImagesConfig) {
    const imagePath = `/src/assets/images/${slideshowFolder}/${config.filename}`;
    const imageModule = imageModules[imagePath];
    if (imageModule) {
      try {
        const { default: imageImport } = await imageModule();
        processedImages.push({
          src: imageImport,
          alt: config.alt || 'Slideshow image',
          caption: config.caption || '',
          filename: config.filename
        });
      } catch (error) {
        // Silent error handling
      }
    }
  }
} else {
  const folderPattern = `/src/assets/images/${slideshowFolder}/`;
  const imagePaths = Object.keys(imageModules)
    .filter(path => path.startsWith(folderPattern))
    .sort((a, b) => {
      const filenameA = a.split('/').pop();
      const filenameB = b.split('/').pop();
      return filenameA.localeCompare(filenameB, undefined, { numeric: true });
    });
  for (const imagePath of imagePaths) {
    const imageModule = imageModules[imagePath];
    try {
      const { default: imageImport } = await imageModule();
      const filename = imagePath.split('/').pop();
      processedImages.push({
        src: imageImport,
        alt: `Slideshow image: ${filename}`,
        caption: '',
        filename
      });
    } catch (error) {
      // Silent error handling
    }
  }
}

const validImages = processedImages.filter(Boolean);
const imageWidths = [400, 768, 1024, 1536, 2048, 2560];
const imageSizes = "100vw";

// Per-instance id
const instanceSuffix = `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
const baseId = id ?? `slide-hero-${instanceSuffix}`;

// Optional: set to 0 for no visible fade; try 20 to test near-invisible crossfade
const crossfadeMs = 25;

// Pass captions to the script
const imageCaptions = validImages.map(img => img.caption || '');
---

<section
  class="relative w-full overflow-hidden not-prose select-none"
  id={baseId}
  style={`--xfade-ms:${crossfadeMs}ms; --header-h: 0px;`}
>
  <!-- First slide is preloaded via <Image preload /> -->

  <div class="absolute top-0 left-0 w-full h-full">
    <!-- Single layer: one image per slide -->
    {validImages.map((img, index) => (
      <Image
        src={img.src}
        alt={img.alt ?? ''}            /* Empty alt by default; overlay carries content */
        aria-hidden="true"             /* Treat slide images as decorative */
        class={`absolute top-0 left-0 w-full h-full object-cover slideshow-image ${index === 0 ? 'active' : ''}`}
        preload={index === 0}
        loading={index === 0 ? 'eager' : 'lazy'}
        fetchpriority={index === 0 ? 'high' : undefined}
        widths={imageWidths}
        sizes={imageSizes}
        format="avif"
        quality="30"
        data-slide-index={index}
      />
    ))}
  </div>

  <!-- Caption overlay -->
  <div 
    id={`${baseId}-caption`}
    class="caption-overlay absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-black bg-opacity-70 text-white px-4 py-2 rounded-lg text-sm font-medium opacity-0 transition-opacity duration-300 pointer-events-none"
    style="z-index: 15;"
  >
    <span class="caption-text"></span>
  </div>

  <!-- Content Overlay -->
  <div class="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center" style="z-index: 10;">
    <div class="text-center max-w-5xl mx-auto px-4 sm:px-6">
      {tagline && (
        <p
          class="text-base text-secondary dark:text-blue-200 font-bold tracking-wide uppercase"
          set:html={tagline}
        />
      )}
      {title && (
        <h1
          class="text-5xl md:text-6xl font-bold leading-tighter tracking-tighter mb-4 font-heading text-white"
          set:html={title}
        />
      )}
      <div class="max-w-3xl mx-auto">
        {subtitle && <p class="text-xl text-white mb-6" set:html={subtitle} />}
        {actions && (
          <div class="max-w-xs sm:max-w-md m-auto flex flex-nowrap flex-col sm:flex-row sm:justify-center gap-4 mb-8">
            {Array.isArray(actions) ? (
              actions.map((action) => (
                <div class="flex w-full sm:w-auto">
                  <Button {...(action || {})} class="w-full sm:mb-0" />
                </div>
              ))
            ) : (
              <Fragment set:html={actions} />
            )}
          </div>
        )}
        {anchorId && (
          <div class="mt-12 flex justify-center">
            <a href={`#${anchorId}`} class="js-scroll bg-transparent hover:bg-white/10 text-white rounded-full p-3 transition-all duration-300 transform hover:translate-y-1 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-white/50" aria-label="Scroll to content">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M16.707 10.293a1 1 0 010 1.414l-6 6a1 1 0 01-1.414 0l-6-6a1 1 0 111.414-1.414L9 14.586V3a1 1 0 012 0v11.586l4.293-4.293a1 1 0 011.414 0z" clip-rule="evenodd" />
              </svg>
            </a>
          </div>
        )}
      </div>
      {content && <Fragment set:html={content} />}
    </div>
  </div>
</section>

<style>
  section {
    /* Use a single height declaration that will be updated by JavaScript */
    height: 100vh; /* Initial fallback */
    height: 100dvh; /* Modern browsers */
  }
  
  /* Remove the calc() from CSS and let JavaScript handle it entirely */
  section.header-calculated {
    height: var(--calculated-height);
  }
  
  .slideshow-image {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    opacity: 0;
    transition: opacity var(--xfade-ms, 0ms) ease;
    pointer-events: none;
  }
  .slideshow-image.active { opacity: 1; }
  .slideshow-image.wc { will-change: opacity; }
  
  .caption-overlay {
    max-width: 90%;
    backdrop-filter: blur(4px);
  }
  
  @media (prefers-reduced-motion: reduce) {
    .slideshow-image { transition-duration: 0ms !important; }
    .caption-overlay { transition-duration: 0ms !important; }
  }
</style>

<script define:vars={{ imageDuration, baseId, crossfadeMs, imageCaptions }}>
  let currentImageIndex = 0;
  let timer;
  let running = false;
  let visibilityHandler;
  let intersectionObserver;
  let resizeObserver;
  let mutationObserver;
  let isPausedByUser = false;
  let pauseTimeout;
  let touchStartY = 0;
  let touchStartTime = 0;
  let hasScrolled = false;

  function getRoot() {
    return document.getElementById(baseId);
  }

  function getImages() {
    const root = getRoot();
    return root ? Array.from(root.querySelectorAll('.slideshow-image')) : [];
  }

  function getCaptionElement() {
    return document.getElementById(`${baseId}-caption`);
  }

  function updateCaption() {
    const captionElement = getCaptionElement();
    if (!captionElement) return;

    const currentCaption = imageCaptions[currentImageIndex];
    const captionText = captionElement.querySelector('.caption-text');
    
    if (captionText) {
      captionText.textContent = currentCaption || '';
    }

    // Show caption only when paused and caption exists
    if (isPausedByUser && currentCaption && currentCaption.trim()) {
      captionElement.style.opacity = '1';
    } else {
      captionElement.style.opacity = '0';
    }
  }

  function decodeIfNeeded(img) {
    if (!img) return Promise.resolve();
    if (typeof img.decode === 'function') {
      return img.decode().catch(() => {});
    }
    if (!img.complete) {
      return new Promise((resolve) => {
        img.addEventListener('load', resolve, { once: true });
        img.addEventListener('error', resolve, { once: true });
      });
    }
    return Promise.resolve();
  }

  async function showIndex(index) {
    const images = getImages();
    if (images.length === 0) return;

    const nextIndex = ((index % images.length) + images.length) % images.length;
    const current = images[currentImageIndex];
    const next = images[nextIndex];

    await decodeIfNeeded(next);

    requestAnimationFrame(() => {
      if (next) next.classList.add('active', 'wc');
      if (current) current.classList.add('wc');
      requestAnimationFrame(() => {
        if (current) current.classList.remove('active');
        currentImageIndex = nextIndex;
        
        // Update caption after image change
        updateCaption();
        
        const dropWC = () => {
          next && next.classList.remove('wc');
          current && current.classList.remove('wc');
        };
        if (crossfadeMs > 0) {
          setTimeout(dropWC, crossfadeMs + 20);
        } else {
          dropWC();
        }
      });
    });
  }

  function schedule() {
    clearTimeout(timer);
    const images = getImages();
    if (images.length <= 1) return;
    timer = setTimeout(async () => {
      await showIndex(currentImageIndex + 1);
      if (running && !isPausedByUser) schedule();
    }, imageDuration);
  }

  function start() {
    if (running) return;
    running = true;
    if (!isPausedByUser) {
      schedule();
    }
  }

  function stop() {
    running = false;
    clearTimeout(timer);
  }

  function pauseSlideshow() {
    if (isPausedByUser) return;
    isPausedByUser = true;
    clearTimeout(timer);
    clearTimeout(pauseTimeout);
    updateCaption(); // Show caption when paused
  }

  function resumeSlideshow() {
    if (!isPausedByUser) return;
    isPausedByUser = false;
    clearTimeout(pauseTimeout);
    updateCaption(); // Hide caption when resumed
    
    // Resume after a short delay to prevent immediate triggering
    pauseTimeout = setTimeout(() => {
      if (running && !isPausedByUser) {
        schedule();
      }
    }, 100);
  }

  function setupUserInteractionPause() {
    const root = getRoot();
    if (!root) return;

    // Mouse events for desktop
    const handleMouseDown = (e) => {
      // Only pause on left click
      if (e.button === 0) {
        pauseSlideshow();
      }
    };

    const handleMouseUp = (e) => {
      if (e.button === 0) {
        resumeSlideshow();
      }
    };

    const handleMouseLeave = () => {
      resumeSlideshow();
    };

    // Touch events for mobile with scroll detection
    const handleTouchStart = (e) => {
      touchStartY = e.touches[0].clientY;
      touchStartTime = Date.now();
      hasScrolled = false;
      
      // Start a timer to detect if this is a tap vs scroll
      setTimeout(() => {
        if (!hasScrolled && Date.now() - touchStartTime < 200) {
          pauseSlideshow();
        }
      }, 50);
    };

    const handleTouchMove = (e) => {
      if (!e.touches[0]) return;
      
      const currentY = e.touches[0].clientY;
      const deltaY = Math.abs(currentY - touchStartY);
      
      // If moved more than 10px, consider it scrolling
      if (deltaY > 10) {
        hasScrolled = true;
        resumeSlideshow();
      }
    };

    const handleTouchEnd = (e) => {
      const touchDuration = Date.now() - touchStartTime;
      
      // If it was a quick tap without scrolling, pause briefly then resume
      if (!hasScrolled && touchDuration < 300) {
        // Already paused in touchStart, now resume after a moment
        setTimeout(() => {
          resumeSlideshow();
        }, 1000); // Hold pause for 1 second on tap
      } else {
        // Was scrolling or long press, resume immediately
        resumeSlideshow();
      }
    };

    const handleTouchCancel = () => {
      hasScrolled = true;
      resumeSlideshow();
    };

    // Add event listeners
    root.addEventListener('mousedown', handleMouseDown);
    root.addEventListener('mouseup', handleMouseUp);
    root.addEventListener('mouseleave', handleMouseLeave);
    
    // Touch events with passive: false only for touchstart to allow preventDefault if needed
    root.addEventListener('touchstart', handleTouchStart, { passive: true });
    root.addEventListener('touchmove', handleTouchMove, { passive: true });
    root.addEventListener('touchend', handleTouchEnd, { passive: true });
    root.addEventListener('touchcancel', handleTouchCancel, { passive: true });

    // Cleanup function
    const cleanup = () => {
      root.removeEventListener('mousedown', handleMouseDown);
      root.removeEventListener('mouseup', handleMouseUp);
      root.removeEventListener('mouseleave', handleMouseLeave);
      root.removeEventListener('touchstart', handleTouchStart);
      root.removeEventListener('touchmove', handleTouchMove);
      root.removeEventListener('touchend', handleTouchEnd);
      root.removeEventListener('touchcancel', handleTouchCancel);
    };

    // Store cleanup for later use
    window.addEventListener('pagehide', cleanup, { once: true });
    
    return cleanup;
  }

  // Completely rewritten header height calculation
  function observeHeaderOffset() {
    const root = getRoot();
    if (!root) return;

    const updateHeight = () => {
      // Try to find the header element
      const header = document.querySelector('header') || 
                    document.querySelector('[data-aw-sticky-header]');
      
      let headerHeight = 0;
      
      if (header) {
        // Force a reflow to get accurate measurements
        header.offsetHeight;
        const rect = header.getBoundingClientRect();
        headerHeight = Math.ceil(rect.height);
        console.log('Header height detected:', headerHeight);
      } else {
        console.log('Header not found, using fallback');
        // Fallback based on your header CSS - looks like it should be around 70-80px
        headerHeight = 76; // A reasonable estimate based on typical header heights
      }
      
      // Calculate the height using JavaScript
      const viewportHeight = window.innerHeight;
      const calculatedHeight = Math.max(viewportHeight - headerHeight, 300); // Minimum 300px
      
      console.log('Viewport height:', viewportHeight, 'Header height:', headerHeight, 'Calculated height:', calculatedHeight);
      
      // Apply the calculated height
      root.style.setProperty('--calculated-height', `${calculatedHeight}px`);
      root.classList.add('header-calculated');
      
      // Force a repaint
      root.offsetHeight;
    };

    // Multiple attempts to get accurate height
    const scheduleUpdate = () => {
      // Immediate update
      updateHeight();
      
      // Additional updates to catch any layout changes
      setTimeout(updateHeight, 100);
      setTimeout(updateHeight, 300);
      setTimeout(updateHeight, 500);
      setTimeout(updateHeight, 1000);
    };

    // Initial update
    if (document.readyState === 'complete') {
      scheduleUpdate();
    } else {
      window.addEventListener('load', scheduleUpdate, { once: true });
      // Also try on DOMContentLoaded
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', scheduleUpdate, { once: true });
      } else {
        scheduleUpdate();
      }
    }

    // Watch for header changes
    const header = document.querySelector('header');
    if (header && window.ResizeObserver) {
      resizeObserver = new ResizeObserver(() => {
        requestAnimationFrame(updateHeight);
      });
      resizeObserver.observe(header);
    }

    // Watch for window resize
    const resizeHandler = () => {
      requestAnimationFrame(updateHeight);
    };
    window.addEventListener('resize', resizeHandler);

    // Watch for header attribute changes (like sticky state)
    if (header && window.MutationObserver) {
      mutationObserver = new MutationObserver(() => {
        requestAnimationFrame(updateHeight);
      });
      mutationObserver.observe(header, {
        attributes: true,
        attributeFilter: ['class', 'style']
      });
    }

    // Cleanup
    window.addEventListener('pagehide', () => {
      window.removeEventListener('resize', resizeHandler);
      if (resizeObserver) resizeObserver.disconnect();
      if (mutationObserver) mutationObserver.disconnect();
    }, { once: true });
  }

  function setupVisibilityPause() {
    visibilityHandler = () => {
      if (document.hidden) stop();
      else start();
    };
    document.addEventListener('visibilitychange', visibilityHandler);
  }

  function setupIntersectionGate() {
    const root = getRoot();
    if (!root || !('IntersectionObserver' in window)) {
      start();
      return;
    }
    intersectionObserver = new IntersectionObserver((entries) => {
      entries.forEach((e) => {
        if (e.target !== root) return;
        if (e.isIntersecting && e.intersectionRatio > 0) start();
        else stop();
      });
    }, { root: null, threshold: 0.1 });
    intersectionObserver.observe(root);
  }

  function cleanup() {
    stop();
    isPausedByUser = false;
    clearTimeout(pauseTimeout);
    
    if (visibilityHandler) {
      document.removeEventListener('visibilitychange', visibilityHandler);
      visibilityHandler = null;
    }
    if (intersectionObserver) {
      intersectionObserver.disconnect();
      intersectionObserver = null;
    }
    if (resizeObserver) {
      resizeObserver.disconnect();
      resizeObserver = null;
    }
    if (mutationObserver) {
      mutationObserver.disconnect();
      mutationObserver = null;
    }
  }

  function init() {
    const images = getImages();
    const first = images[0];
    decodeIfNeeded(first).then(() => {
      const second = images[1];
      decodeIfNeeded(second);
      setupIntersectionGate();
      setupVisibilityPause();
      setupUserInteractionPause(); // Add user interaction pause
      updateCaption(); // Initialize caption
    });
    
    // Start height observation immediately
    observeHeaderOffset();
    
    window.addEventListener('pagehide', cleanup, { once: true });
  }

  // Start initialization
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
</script>