---
import Button from '~/components/ui/Button.astro';
import { Image } from 'astro:assets';
import type { Hero as Props } from '~/types';

export interface SlideHeroProps extends Props {
  slideshow?: {
    images?: Array<{ filename: string; alt?: string }>;
    folder?: string;
    duration?: number;
  };
}

const {
  title = await Astro.slots.render('title'),
  subtitle = await Astro.slots.render('subtitle'),
  tagline,
  content = await Astro.slots.render('content'),
  actions = await Astro.slots.render('actions'),
  id,
  anchorId,
  slideshow = { folder: 'slideshow', duration: 3000 },
} = Astro.props as SlideHeroProps;

const slideshowImages = slideshow.images;
const slideshowFolder = slideshow.folder || 'slideshow';
const imageDuration = slideshow.duration || 3000;

const imageModules = import.meta.glob('/src/assets/images/**/*.{jpg,jpeg,png,webp,JPG,JPEG,PNG,WEBP}', { eager: false });

let processedImages = [];

if (slideshowImages) {
  for (const config of slideshowImages) {
    const imagePath = `/src/assets/images/${slideshowFolder}/${config.filename}`;
    const imageModule = imageModules[imagePath];
    if (imageModule) {
      try {
        const { default: imageImport } = await imageModule();
        processedImages.push({
          src: imageImport,
          alt: config.alt || 'Slideshow image',
          filename: config.filename
        });
      } catch (error) {
        // Silent error handling
      }
    }
  }
} else {
  const folderPattern = `/src/assets/images/${slideshowFolder}/`;
  const imagePaths = Object.keys(imageModules)
    .filter(path => path.startsWith(folderPattern))
    .sort((a, b) => {
      const filenameA = a.split('/').pop();
      const filenameB = b.split('/').pop();
      return filenameA.localeCompare(filenameB, undefined, { numeric: true });
    });
  for (const imagePath of imagePaths) {
    const imageModule = imageModules[imagePath];
    try {
      const { default: imageImport } = await imageModule();
      const filename = imagePath.split('/').pop();
      processedImages.push({
        src: imageImport,
        alt: `Slideshow image: ${filename}`,
        filename
      });
    } catch (error) {
      // Silent error handling
    }
  }
}

const validImages = processedImages.filter(Boolean);
const imageWidths = [400, 768, 1024, 1536, 2048, 2560];
const imageSizes = "100vw";

// Per-instance id
const instanceSuffix = `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
const baseId = id ?? `slide-hero-${instanceSuffix}`;

// Optional: set to 0 for no visible fade; try 20 to test near-invisible crossfade
const crossfadeMs = 25;
---

<section
  class="relative w-full overflow-hidden not-prose select-none"
  id={baseId}
  style={`--xfade-ms:${crossfadeMs}ms; min-height:100dvh; height:calc(100dvh - var(--header-h, 0px));`}
>
  <!-- First slide is preloaded via <Image preload /> -->

  <div class="absolute top-0 left-0 w-full h-full">
    <!-- Single layer: one image per slide -->
    {validImages.map((img, index) => (
      <Image
        src={img.src}
        alt={img.alt ?? ''}            /* Empty alt by default; overlay carries content */
        aria-hidden="true"             /* Treat slide images as decorative */
        class={`absolute top-0 left-0 w-full h-full object-cover slideshow-image ${index === 0 ? 'active' : ''}`}
        preload={index === 0}
        loading={index === 0 ? 'eager' : 'lazy'}
        fetchpriority={index === 0 ? 'high' : undefined}
        widths={imageWidths}
        sizes={imageSizes}
        format="avif"
        quality="30"
        data-slide-index={index}
      />
    ))}
  </div>

  <!-- Content Overlay -->
  <div class="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center" style="z-index: 10;">
    <div class="text-center max-w-5xl mx-auto px-4 sm:px-6">
      {tagline && (
        <p
          class="text-base text-secondary dark:text-blue-200 font-bold tracking-wide uppercase"
          set:html={tagline}
        />
      )}
      {title && (
        <h1
          class="text-5xl md:text-6xl font-bold leading-tighter tracking-tighter mb-4 font-heading text-white"
          set:html={title}
        />
      )}
      <div class="max-w-3xl mx-auto">
        {subtitle && <p class="text-xl text-white mb-6" set:html={subtitle} />}
        {actions && (
          <div class="max-w-xs sm:max-w-md m-auto flex flex-nowrap flex-col sm:flex-row sm:justify-center gap-4 mb-8">
            {Array.isArray(actions) ? (
              actions.map((action) => (
                <div class="flex w-full sm:w-auto">
                  <Button {...(action || {})} class="w-full sm:mb-0" />
                </div>
              ))
            ) : (
              <Fragment set:html={actions} />
            )}
          </div>
        )}
        {anchorId && (
          <div class="mt-12 flex justify-center">
            <a href={`#${anchorId}`} class="js-scroll bg-transparent hover:bg-white/10 text-white rounded-full p-3 transition-all duration-300 transform hover:translate-y-1 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-white/50" aria-label="Scroll to content">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M16.707 10.293a1 1 0 010 1.414l-6 6a1 1 0 01-1.414 0l-6-6a1 1 0 111.414-1.414L9 14.586V3a1 1 0 012 0v11.586l4.293-4.293a1 1 0 011.414 0z" clip-rule="evenodd" />
              </svg>
            </a>
          </div>
        )}
      </div>
      {content && <Fragment set:html={content} />}
    </div>
  </div>
</section>

<style>
  .slideshow-image {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    opacity: 0;
    transition: opacity var(--xfade-ms, 0ms) ease;
    pointer-events: none;
  }
  .slideshow-image.active { opacity: 1; }
  .slideshow-image.wc { will-change: opacity; }
  @media (prefers-reduced-motion: reduce) {
    .slideshow-image { transition-duration: 0ms !important; }
  }
</style>

<script define:vars={{ imageDuration, baseId, crossfadeMs }}>
  let currentImageIndex = 0;
  let timer;
  let running = false;
  let visibilityHandler;
  let intersectionObserver;
  let resizeObserver;

  function getRoot() {
    return document.getElementById(baseId);
  }

  function getImages() {
    const root = getRoot();
    return root ? Array.from(root.querySelectorAll('.slideshow-image')) : [];
  }

  function decodeIfNeeded(img) {
    if (!img) return Promise.resolve();
    if (typeof img.decode === 'function') {
      return img.decode().catch(() => {});
    }
    if (!img.complete) {
      return new Promise((resolve) => {
        img.addEventListener('load', resolve, { once: true });
        img.addEventListener('error', resolve, { once: true });
      });
    }
    return Promise.resolve();
  }

  async function showIndex(index) {
    const images = getImages();
    if (images.length === 0) return;

    const nextIndex = ((index % images.length) + images.length) % images.length;
    const current = images[currentImageIndex];
    const next = images[nextIndex];

    // Ensure the next image is ready to paint
    await decodeIfNeeded(next);

    // Add next first, then remove current on the next frame to avoid any transparent gap
    requestAnimationFrame(() => {
      if (next) next.classList.add('active', 'wc');
      if (current) current.classList.add('wc');
      requestAnimationFrame(() => {
        if (current) current.classList.remove('active');
        currentImageIndex = nextIndex;
        // Drop will-change after the transition window
        const dropWC = () => {
          next && next.classList.remove('wc');
          current && current.classList.remove('wc');
        };
        if (crossfadeMs > 0) {
          setTimeout(dropWC, crossfadeMs + 20);
        } else {
          dropWC();
        }
      });
    });
  }

  function schedule() {
    clearTimeout(timer);
    const images = getImages();
    if (images.length <= 1) return;
    timer = setTimeout(async () => {
      await showIndex(currentImageIndex + 1);
      if (running) schedule();
    }, imageDuration);
  }

  function start() {
    if (running) return;
    running = true;
    schedule();
  }

  function stop() {
    running = false;
    clearTimeout(timer);
  }

  // Observe header height and set a CSS var so the section height = 100dvh - header
  function observeHeaderOffset() {
    const root = getRoot();
    const header = document.querySelector('header');
    if (!root || !header) return;

    const apply = () => {
      const h = header.offsetHeight || 0;
      root.style.setProperty('--header-h', `${h}px`);
    };

    resizeObserver = new ResizeObserver(apply);
    resizeObserver.observe(header);
    apply();

    window.addEventListener('resize', apply);
  }

  function setupVisibilityPause() {
    visibilityHandler = () => {
      if (document.hidden) stop();
      else start();
    };
    document.addEventListener('visibilitychange', visibilityHandler);
  }

  function setupIntersectionGate() {
    const root = getRoot();
    if (!root || !('IntersectionObserver' in window)) {
      start();
      return;
    }
    intersectionObserver = new IntersectionObserver((entries) => {
      entries.forEach((e) => {
        if (e.target !== root) return;
        if (e.isIntersecting && e.intersectionRatio > 0) start();
        else stop();
      });
    }, { root: null, threshold: 0.1 });
    intersectionObserver.observe(root);
  }

  function cleanup() {
    stop();
    if (visibilityHandler) {
      document.removeEventListener('visibilitychange', visibilityHandler);
      visibilityHandler = null;
    }
    if (intersectionObserver) {
      intersectionObserver.disconnect();
      intersectionObserver = null;
    }
    if (resizeObserver) {
      resizeObserver.disconnect();
      resizeObserver = null;
    }
  }

  function init() {
    const images = getImages();
    const first = images[0];
    decodeIfNeeded(first).then(() => {
      const second = images[1];
      decodeIfNeeded(second);
      setupIntersectionGate();
      setupVisibilityPause();
     });
     observeHeaderOffset();
     window.addEventListener('pagehide', cleanup, { once: true });
  }

  document.addEventListener('DOMContentLoaded', init);
</script>